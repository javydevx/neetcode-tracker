[
  {
    "title": "Two Pointers",
    "description": "Used for sorted arrays, reversing, removing elements, comparing ends. Great for reducing O(n²) to O(n).",
    "templates": {
      "python": "left, right = 0, len(arr) - 1\nwhile left < right:\n    # process values at arr[left] and arr[right]\n    if some_condition:\n        left += 1\n    else:\n        right -= 1",
      "javascript": "let left = 0, right = arr.length - 1;\nwhile (left < right) {\n    // process values at arr[left] and arr[right]\n    if (someCondition) {\n        left++;\n    } else {\n        right--;\n    }\n}",
      "java": "int left = 0, right = arr.length - 1;\nwhile (left < right) {\n    // process values at arr[left] and arr[right]\n    if (someCondition) {\n        left++;\n    } else {\n        right--;\n    }\n}",
      "go": "left, right := 0, len(arr)-1\nfor left < right {\n    // process values at arr[left] and arr[right]\n    if someCondition {\n        left++\n    } else {\n        right--\n    }\n}"
    },
    "problems": [
      "Valid Palindrome",
      "Two Sum II",
      "Remove Duplicates from Sorted Array"
    ]
  },
  {
    "title": "Sliding Window",
    "description": "Sliding Window is a technique to efficiently handle contiguous subarrays or substrings. Two major forms exist: (1) Fixed-size window (size = k), used for sums/averages and constant-length subarrays; (2) Dynamic (variable-size) window, used when the window expands and shrinks based on a condition (e.g., character frequency, distinct characters, constraints). For binary arrays or situations where only one counter is needed, an optimized dynamic window without a hashmap can be used.",
    "templates": {
      "python": "# ---------------------------\n# Version 1: Fixed-Size Window (size = k)\n# ---------------------------\nleft = 0\nwindow_sum = 0\nbest = 0\n\nfor right in range(len(arr)):\n    window_sum += arr[right]\n\n    # When window reaches size k\n    if right - left + 1 == k:\n        best = max(best, window_sum)\n        window_sum -= arr[left]\n        left += 1\n\n\n# ---------------------------\n# Version 2: Dynamic Window (variable size, with hashmap)\n# ---------------------------\nleft = 0\nmax_len = 0\ncount = {}\n\nfor right in range(len(s)):\n    char = s[right]\n    count[char] = count.get(char, 0) + 1\n\n    # Shrink window while it violates a condition\n    while window_invalid:\n        count[s[left]] -= 1\n        if count[s[left]] == 0:\n            del count[s[left]]\n        left += 1\n\n    max_len = max(max_len, right - left + 1)\n\n\n# ---------------------------\n# Version 3: Dynamic Window (optimized counters, no hashmap)\n# ---------------------------\nleft = 0\nmax_len = 0\ncounter = 0  # counts \"bad\" elements in the window (e.g., zeros)\n\nfor right in range(len(nums)):\n    if nums[right] == bad_element:  # e.g., 0 in binary arrays\n        counter += 1\n\n    # Shrink window if it violates the allowed limit\n    while counter > limit:\n        if nums[left] == bad_element:\n            counter -= 1\n        left += 1\n\n    max_len = max(max_len, right - left + 1)  # adjust -1 if problem requires deletion",
      "javascript": "// ---------------------------\n// Version 1: Fixed-Size Window (size = k)\n// ---------------------------\nlet left = 0;\nlet windowSum = 0;\nlet best = 0;\n\nfor (let right = 0; right < arr.length; right++) {\n    windowSum += arr[right];\n\n    if (right - left + 1 === k) {\n        best = Math.max(best, windowSum);\n        windowSum -= arr[left];\n        left++;\n    }\n}\n\n// ---------------------------\n// Version 2: Dynamic Window (variable size, with hashmap)\n// ---------------------------\nlet left2 = 0;\nlet maxLen = 0;\nlet count = {};\n\nfor (let right = 0; right < s.length; right++) {\n    const char = s[right];\n    count[char] = (count[char] || 0) + 1;\n\n    while (windowInvalid) {\n        count[s[left2]]--;\n        if (count[s[left2]] === 0) delete count[s[left2]];\n        left2++;\n    }\n\n    maxLen = Math.max(maxLen, right - left2 + 1);\n}\n\n// ---------------------------\n// Version 3: Dynamic Window (optimized counters, no hashmap)\n// ---------------------------\nlet left3 = 0;\nlet maxLen2 = 0;\nlet counter = 0; // counts bad elements\n\nfor (let right = 0; right < nums.length; right++) {\n    if (nums[right] === badElement) counter++;\n\n    while (counter > limit) {\n        if (nums[left3] === badElement) counter--;\n        left3++;\n    }\n\n    maxLen2 = Math.max(maxLen2, right - left3 + 1);\n}",
      "java": "// ---------------------------\n// Version 1: Fixed-Size Window (size = k)\n// ---------------------------\nint left = 0;\nint windowSum = 0;\nint best = 0;\n\nfor (int right = 0; right < arr.length; right++) {\n    windowSum += arr[right];\n\n    if (right - left + 1 == k) {\n        best = Math.max(best, windowSum);\n        windowSum -= arr[left];\n        left++;\n    }\n}\n\n// ---------------------------\n// Version 2: Dynamic Window (variable size, with hashmap)\n// ---------------------------\nint left2 = 0;\nint maxLen = 0;\nMap<Character, Integer> count = new HashMap<>();\n\nfor (int right = 0; right < s.length(); right++) {\n    char c = s.charAt(right);\n    count.put(c, count.getOrDefault(c, 0) + 1);\n\n    while (windowInvalid) {\n        char lc = s.charAt(left2);\n        count.put(lc, count.get(lc) - 1);\n        if (count.get(lc) == 0) count.remove(lc);\n        left2++;\n    }\n\n    maxLen = Math.max(maxLen, right - left2 + 1);\n}\n\n// ---------------------------\n// Version 3: Dynamic Window (optimized counters, no hashmap)\n// ---------------------------\nint left3 = 0;\nint maxLen2 = 0;\nint counter = 0;\n\nfor (int right = 0; right < nums.length; right++) {\n    if (nums[right] == badElement) counter++;\n\n    while (counter > limit) {\n        if (nums[left3] == badElement) counter--;\n        left3++;\n    }\n\n    maxLen2 = Math.max(maxLen2, right - left3 + 1);\n}",
      "go": "// ---------------------------\n// Version 1: Fixed-Size Window (size = k)\n// ---------------------------\nleft := 0\nwindowSum := 0\nbest := 0\n\nfor right := 0; right < len(arr); right++ {\n    windowSum += arr[right]\n\n    if right-left+1 == k {\n        if windowSum > best {\n            best = windowSum\n        }\n        windowSum -= arr[left]\n        left++\n    }\n}\n\n// ---------------------------\n// Version 2: Dynamic Window (variable size, with hashmap)\n// ---------------------------\nleft2 := 0\nmaxLen := 0\ncount := make(map[rune]int)\n\nfor right, char := range s {\n    count[char]++\n\n    for windowInvalid {\n        leftChar := rune(s[left2])\n        count[leftChar]--\n        if count[leftChar] == 0 {\n            delete(count, leftChar)\n        }\n        left2++\n    }\n\n    if right-left2+1 > maxLen {\n        maxLen = right-left2+1\n    }\n}\n\n// ---------------------------\n// Version 3: Dynamic Window (optimized counters, no hashmap)\n// ---------------------------\nleft3 := 0\nmaxLen2 := 0\ncounter := 0\n\nfor right := 0; right < len(nums); right++ {\n    if nums[right] == badElement {\n        counter++\n    }\n\n    for counter > limit {\n        if nums[left3] == badElement {\n            counter--\n        }\n        left3++\n    }\n\n    if right-left3+1 > maxLen2 {\n        maxLen2 = right-left3+1\n    }\n}"
    },
    "problems": [
      "Maximum Sum Subarray of Size K",
      "Count Good Substrings of Size K",
      "Longest Substring Without Repeating Characters",
      "Longest Substring with K Distinct Characters",
      "Minimum Window Substring",
      "Permutation in String",
      "Smallest Subarray With Sum ≥ Target",
      "Longest Subarray of 1's After Deleting One Element",
      "Max Consecutive Ones III"
    ]
  },
  {
    "title": "Monotonic Stack",
    "description": "Used for finding next/previous greater or smaller elements. Maintains elements in monotonic (increasing or decreasing) order. Two variants: (1) Monotonic Decreasing Stack - for next greater element problems; (2) Monotonic Increasing Stack - for next smaller element problems. The stack stores indices (not values) to track positions.",
    "templates": {
      "python": "# ---------------------------\n# Version 1: Monotonic Decreasing (Next Greater Element)\n# ---------------------------\nstack = []  # stores indices\nresult = [-1] * len(arr)\n\nfor i in range(len(arr)):\n    # Pop smaller elements - current is their next greater\n    while stack and arr[stack[-1]] < arr[i]:\n        idx = stack.pop()\n        result[idx] = arr[i]\n    stack.append(i)\n\n\n# ---------------------------\n# Version 2: Monotonic Increasing (Next Smaller Element)\n# ---------------------------\nstack = []  # stores indices\nresult = [-1] * len(arr)\n\nfor i in range(len(arr)):\n    # Pop larger elements - current is their next smaller\n    while stack and arr[stack[-1]] > arr[i]:\n        idx = stack.pop()\n        result[idx] = arr[i]\n    stack.append(i)\n\n\n# ---------------------------\n# Version 3: Previous Greater/Smaller (traverse left to right)\n# ---------------------------\nstack = []\nresult = [-1] * len(arr)\n\nfor i in range(len(arr)):\n    # Pop until we find previous greater (or smaller)\n    while stack and arr[stack[-1]] <= arr[i]:  # change condition as needed\n        stack.pop()\n    \n    if stack:\n        result[i] = arr[stack[-1]]  # previous greater element\n    \n    stack.append(i)",
      "javascript": "// ---------------------------\n// Version 1: Monotonic Decreasing (Next Greater Element)\n// ---------------------------\nconst stack = [];  // stores indices\nconst result = new Array(arr.length).fill(-1);\n\nfor (let i = 0; i < arr.length; i++) {\n    // Pop smaller elements - current is their next greater\n    while (stack.length && arr[stack[stack.length - 1]] < arr[i]) {\n        const idx = stack.pop();\n        result[idx] = arr[i];\n    }\n    stack.push(i);\n}\n\n\n// ---------------------------\n// Version 2: Monotonic Increasing (Next Smaller Element)\n// ---------------------------\nconst stack2 = [];  // stores indices\nconst result2 = new Array(arr.length).fill(-1);\n\nfor (let i = 0; i < arr.length; i++) {\n    // Pop larger elements - current is their next smaller\n    while (stack2.length && arr[stack2[stack2.length - 1]] > arr[i]) {\n        const idx = stack2.pop();\n        result2[idx] = arr[i];\n    }\n    stack2.push(i);\n}\n\n\n// ---------------------------\n// Version 3: Previous Greater/Smaller (traverse left to right)\n// ---------------------------\nconst stack3 = [];\nconst result3 = new Array(arr.length).fill(-1);\n\nfor (let i = 0; i < arr.length; i++) {\n    // Pop until we find previous greater (or smaller)\n    while (stack3.length && arr[stack3[stack3.length - 1]] <= arr[i]) {\n        stack3.pop();\n    }\n    \n    if (stack3.length) {\n        result3[i] = arr[stack3[stack3.length - 1]];\n    }\n    \n    stack3.push(i);\n}",
      "java": "// ---------------------------\n// Version 1: Monotonic Decreasing (Next Greater Element)\n// ---------------------------\nStack<Integer> stack = new Stack<>();  // stores indices\nint[] result = new int[arr.length];\nArrays.fill(result, -1);\n\nfor (int i = 0; i < arr.length; i++) {\n    // Pop smaller elements - current is their next greater\n    while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {\n        int idx = stack.pop();\n        result[idx] = arr[i];\n    }\n    stack.push(i);\n}\n\n\n// ---------------------------\n// Version 2: Monotonic Increasing (Next Smaller Element)\n// ---------------------------\nStack<Integer> stack2 = new Stack<>();  // stores indices\nint[] result2 = new int[arr.length];\nArrays.fill(result2, -1);\n\nfor (int i = 0; i < arr.length; i++) {\n    // Pop larger elements - current is their next smaller\n    while (!stack2.isEmpty() && arr[stack2.peek()] > arr[i]) {\n        int idx = stack2.pop();\n        result2[idx] = arr[i];\n    }\n    stack2.push(i);\n}\n\n\n// ---------------------------\n// Version 3: Previous Greater/Smaller (traverse left to right)\n// ---------------------------\nStack<Integer> stack3 = new Stack<>();\nint[] result3 = new int[arr.length];\nArrays.fill(result3, -1);\n\nfor (int i = 0; i < arr.length; i++) {\n    // Pop until we find previous greater (or smaller)\n    while (!stack3.isEmpty() && arr[stack3.peek()] <= arr[i]) {\n        stack3.pop();\n    }\n    \n    if (!stack3.isEmpty()) {\n        result3[i] = arr[stack3.peek()];\n    }\n    \n    stack3.push(i);\n}",
      "go": "// ---------------------------\n// Version 1: Monotonic Decreasing (Next Greater Element)\n// ---------------------------\nstack := []int{}  // stores indices\nresult := make([]int, len(arr))\nfor i := range result {\n    result[i] = -1\n}\n\nfor i := 0; i < len(arr); i++ {\n    // Pop smaller elements - current is their next greater\n    for len(stack) > 0 && arr[stack[len(stack)-1]] < arr[i] {\n        idx := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        result[idx] = arr[i]\n    }\n    stack = append(stack, i)\n}\n\n\n// ---------------------------\n// Version 2: Monotonic Increasing (Next Smaller Element)\n// ---------------------------\nstack2 := []int{}  // stores indices\nresult2 := make([]int, len(arr))\nfor i := range result2 {\n    result2[i] = -1\n}\n\nfor i := 0; i < len(arr); i++ {\n    // Pop larger elements - current is their next smaller\n    for len(stack2) > 0 && arr[stack2[len(stack2)-1]] > arr[i] {\n        idx := stack2[len(stack2)-1]\n        stack2 = stack2[:len(stack2)-1]\n        result2[idx] = arr[i]\n    }\n    stack2 = append(stack2, i)\n}\n\n\n// ---------------------------\n// Version 3: Previous Greater/Smaller (traverse left to right)\n// ---------------------------\nstack3 := []int{}\nresult3 := make([]int, len(arr))\nfor i := range result3 {\n    result3[i] = -1\n}\n\nfor i := 0; i < len(arr); i++ {\n    // Pop until we find previous greater (or smaller)\n    for len(stack3) > 0 && arr[stack3[len(stack3)-1]] <= arr[i] {\n        stack3 = stack3[:len(stack3)-1]\n    }\n    \n    if len(stack3) > 0 {\n        result3[i] = arr[stack3[len(stack3)-1]]\n    }\n    \n    stack3 = append(stack3, i)\n}"
    },
    "problems": [
      "Next Greater Element I",
      "Next Greater Element II",
      "Daily Temperatures",
      "Largest Rectangle in Histogram",
      "Trapping Rain Water",
      "Remove K Digits",
      "Online Stock Span"
    ]
  },
  {
    "title": "Fast and Slow Pointers",
    "description": "Used for cycle detection in linked lists or arrays.",
    "templates": {
      "python": "def hasCycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
      "javascript": "function hasCycle(head) {\n    let slow = head, fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n}",
      "java": "public boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}",
      "go": "func hasCycle(head *ListNode) bool {\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}"
    },
    "problems": [
      "Linked List Cycle",
      "Find Duplicate Number",
      "Middle of the Linked List"
    ]
  },
  {
    "title": "Hashing (Set / Dictionary)",
    "description": "Used for frequency counting, quick lookup.",
    "templates": {
      "python": "freq = {}\nfor num in arr:\n    freq[num] = freq.get(num, 0) + 1",
      "javascript": "const freq = {};\nfor (const num of arr) {\n    freq[num] = (freq[num] || 0) + 1;\n}",
      "java": "Map<Integer, Integer> freq = new HashMap<>();\nfor (int num : arr) {\n    freq.put(num, freq.getOrDefault(num, 0) + 1);\n}",
      "go": "freq := make(map[int]int)\nfor _, num := range arr {\n    freq[num]++\n}"
    },
    "problems": ["Two Sum", "Group Anagrams", "Top K Frequent Elements"]
  },
  {
    "title": "Binary Search",
    "description": "Used for sorted arrays, search space problems.",
    "templates": {
      "python": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
      "javascript": "function binarySearch(arr, target) {\n    let left = 0, right = arr.length - 1;\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid] === target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}",
      "java": "public int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}",
      "go": "func binarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}"
    },
    "problems": [
      "Binary Search",
      "Search Insert Position",
      "Find Minimum in Rotated Sorted Array"
    ]
  },
  {
    "title": "Prefix Sum",
    "description": "Used for fast range sum queries and subarray sum problems. Two common implementations: (1) with an extra 0 at the start, which makes range sums easier, and (2) without the extra 0, using 0-based indexing.",
    "templates": {
      "python": "# ---------------------------\n# Version 1: With extra 0 at the start (simpler range queries)\n# ---------------------------\nprefix = [0] * (len(arr) + 1)\nfor i in range(len(arr)):\n    prefix[i + 1] = prefix[i] + arr[i]\n\n# ---------------------------\n# Version 2: Without extra 0 (0-based indexing)\n# ---------------------------\nprefix = [0] * len(arr)\nprefix[0] = arr[0]\nfor i in range(1, len(arr)):\n    prefix[i] = prefix[i - 1] + arr[i]",
      "javascript": "// ---------------------------\n// Version 1: With extra 0 at the start (simpler range queries)\n// ---------------------------\nconst prefix = new Array(arr.length + 1).fill(0);\nfor (let i = 0; i < arr.length; i++) {\n    prefix[i + 1] = prefix[i] + arr[i];\n}\n\n// ---------------------------\n// Version 2: Without extra 0 (0-based indexing)\n// ---------------------------\nconst prefix2 = new Array(arr.length).fill(0);\nprefix2[0] = arr[0];\nfor (let i = 1; i < arr.length; i++) {\n    prefix2[i] = prefix2[i - 1] + arr[i];",
      "java": "// ---------------------------\n// Version 1: With extra 0 at the start (simpler range queries)\n// ---------------------------\nint[] prefix = new int[arr.length + 1];\nfor (int i = 0; i < arr.length; i++) {\n    prefix[i + 1] = prefix[i] + arr[i];\n}\n\n// ---------------------------\n// Version 2: Without extra 0 (0-based indexing)\n// ---------------------------\nint[] prefix2 = new int[arr.length];\nprefix2[0] = arr[0];\nfor (int i = 1; i < arr.length; i++) {\n    prefix2[i] = prefix2[i - 1] + arr[i];",
      "go": "// ---------------------------\n// Version 1: With extra 0 at the start (simpler range queries)\n// ---------------------------\nprefix := make([]int, len(arr)+1)\nfor i := 0; i < len(arr); i++ {\n    prefix[i+1] = prefix[i] + arr[i]\n}\n\n// ---------------------------\n// Version 2: Without extra 0 (0-based indexing)\n// ---------------------------\nprefix2 := make([]int, len(arr))\nprefix2[0] = arr[0]\nfor i := 1; i < len(arr); i++ {\n    prefix2[i] = prefix2[i-1] + arr[i];"
    },
    "problems": [
      "Subarray Sum Equals K",
      "Range Sum Query",
      "Continuous Subarray Sum"
    ]
  },
  {
    "title": "Backtracking",
    "description": "Used for generating combinations/permutations.",
    "templates": {
      "python": "def backtrack(path, options):\n    if base_case:\n        result.append(path[:])\n        return\n    for i in range(len(options)):\n        path.append(options[i])\n        backtrack(path, options[i+1:])\n        path.pop()",
      "javascript": "function backtrack(path, options) {\n    if (baseCase) {\n        result.push([...path]);\n        return;\n    }\n    for (let i = 0; i < options.length; i++) {\n        path.push(options[i]);\n        backtrack(path, options.slice(i + 1));\n        path.pop();\n    }\n}",
      "java": "public void backtrack(List<Integer> path, int[] options, int start) {\n    if (baseCase) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (int i = start; i < options.length; i++) {\n        path.add(options[i]);\n        backtrack(path, options, i + 1);\n        path.remove(path.size() - 1);\n    }\n}",
      "go": "func backtrack(path []int, options []int, start int) {\n    if baseCase {\n        result = append(result, append([]int{}, path...))\n        return\n    }\n    for i := start; i < len(options); i++ {\n        path = append(path, options[i])\n        backtrack(path, options, i+1)\n        path = path[:len(path)-1]\n    }\n}"
    },
    "problems": ["Subsets", "Permutations", "N-Queens"]
  },
  {
    "title": "DFS for Trees",
    "description": "Used for traversals, height calculation, path sums.",
    "templates": {
      "python": "def dfs_tree(node):\n    if not node:\n        return\n    # Preorder processing\n    dfs_tree(node.left)\n    dfs_tree(node.right)\n    # Postorder processing",
      "javascript": "function dfsTree(node) {\n    if (!node) return;\n    // Preorder processing\n    dfsTree(node.left);\n    dfsTree(node.right);\n    // Postorder processing\n}",
      "java": "public void dfsTree(TreeNode node) {\n    if (node == null) return;\n    // Preorder processing\n    dfsTree(node.left);\n    dfsTree(node.right);\n    // Postorder processing\n}",
      "go": "func dfsTree(node *TreeNode) {\n    if node == nil {\n        return\n    }\n    // Preorder processing\n    dfsTree(node.Left)\n    dfsTree(node.Right)\n    // Postorder processing\n}"
    },
    "problems": ["Max Depth of Binary Tree", "Path Sum", "Balanced Binary Tree"]
  },
  {
    "title": "BFS for Trees",
    "description": "Used for level order traversal, shortest path in trees.",
    "templates": {
      "python": "from collections import deque\n\ndef bfs_tree(root):\n    if not root:\n        return\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        # process node\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)",
      "javascript": "function bfsTree(root) {\n    if (!root) return;\n    const queue = [root];\n    while (queue.length > 0) {\n        const node = queue.shift();\n        // process node\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n    }\n}",
      "java": "public void bfsTree(TreeNode root) {\n    if (root == null) return;\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        // process node\n        if (node.left != null) queue.offer(node.left);\n        if (node.right != null) queue.offer(node.right);\n    }\n}",
      "go": "func bfsTree(root *TreeNode) {\n    if root == nil {\n        return\n    }\n    queue := []*TreeNode{root}\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        // process node\n        if node.Left != nil {\n            queue = append(queue, node.Left)\n        }\n        if node.Right != nil {\n            queue = append(queue, node.Right)\n        }\n    }\n}"
    },
    "problems": [
      "Binary Tree Level Order Traversal",
      "Minimum Depth of Binary Tree"
    ]
  },
  {
    "title": "Dynamic Programming (DP)",
    "description": "Used for optimal substructure, overlapping subproblems.",
    "templates": {
      "python": "# Memoization approach\ndef dp(i, memo={}):\n    if i in memo:\n        return memo[i]\n    if base_case:\n        return result\n    memo[i] = compute_from_smaller(i)\n    return memo[i]\n\n# Tabulation approach\ndp = [0] * (n + 1)\ndp[0] = base_case\nfor i in range(1, n + 1):\n    dp[i] = compute_from_smaller(i)",
      "javascript": "// Memoization approach\nfunction dp(i, memo = {}) {\n    if (i in memo) return memo[i];\n    if (baseCase) return result;\n    memo[i] = computeFromSmaller(i);\n    return memo[i];\n}\n\n// Tabulation approach\nconst dp = new Array(n + 1).fill(0);\ndp[0] = baseCase;\nfor (let i = 1; i <= n; i++) {\n    dp[i] = computeFromSmaller(i);\n}",
      "java": "// Memoization approach\nMap<Integer, Integer> memo = new HashMap<>();\npublic int dp(int i) {\n    if (memo.containsKey(i)) return memo.get(i);\n    if (baseCase) return result;\n    int res = computeFromSmaller(i);\n    memo.put(i, res);\n    return res;\n}\n\n// Tabulation approach\nint[] dp = new int[n + 1];\ndp[0] = baseCase;\nfor (int i = 1; i <= n; i++) {\n    dp[i] = computeFromSmaller(i);\n}",
      "go": "// Memoization approach\nmemo := make(map[int]int)\nfunc dp(i int) int {\n    if val, ok := memo[i]; ok {\n        return val\n    }\n    if baseCase {\n        return result\n    }\n    memo[i] = computeFromSmaller(i)\n    return memo[i]\n}\n\n// Tabulation approach\ndp := make([]int, n+1)\ndp[0] = baseCase\nfor i := 1; i <= n; i++ {\n    dp[i] = computeFromSmaller(i)\n}"
    },
    "problems": [
      "Climbing Stairs",
      "House Robber",
      "Longest Increasing Subsequence"
    ]
  }
]
