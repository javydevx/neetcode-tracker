[
  {
    "title": "Two Pointers",
    "description": "Used for sorted arrays, reversing, removing elements, comparing ends. Great for reducing O(n²) to O(n).",
    "templates": {
      "python": "left, right = 0, len(arr) - 1\nwhile left < right:\n    # process values at arr[left] and arr[right]\n    if some_condition:\n        left += 1\n    else:\n        right -= 1",
      "javascript": "let left = 0, right = arr.length - 1;\nwhile (left < right) {\n    // process values at arr[left] and arr[right]\n    if (someCondition) {\n        left++;\n    } else {\n        right--;\n    }\n}",
      "java": "int left = 0, right = arr.length - 1;\nwhile (left < right) {\n    // process values at arr[left] and arr[right]\n    if (someCondition) {\n        left++;\n    } else {\n        right--;\n    }\n}",
      "go": "left, right := 0, len(arr)-1\nfor left < right {\n    // process values at arr[left] and arr[right]\n    if someCondition {\n        left++\n    } else {\n        right--\n    }\n}"
    },
    "problems": [
      "Valid Palindrome",
      "Two Sum II",
      "Remove Duplicates from Sorted Array"
    ]
  },
  {
    "title": "Sliding Window",
    "description": "Sliding Window is a technique to efficiently handle contiguous subarrays or substrings. Two major forms exist: (1) Fixed-size window (size = k), used for sums/averages and constant-length subarrays; (2) Dynamic (variable-size) window, used when the window expands and shrinks based on a condition (e.g., character frequency, distinct characters, constraints). For binary arrays or situations where only one counter is needed, an optimized dynamic window without a hashmap can be used.",
    "templates": {
      "python": "# ---------------------------\n# Version 1: Fixed-Size Window (size = k)\n# ---------------------------\nleft = 0\nwindow_sum = 0\nbest = 0\n\nfor right in range(len(arr)):\n    window_sum += arr[right]\n\n    # When window reaches size k\n    if right - left + 1 == k:\n        best = max(best, window_sum)\n        window_sum -= arr[left]\n        left += 1\n\n\n# ---------------------------\n# Version 2: Dynamic Window (variable size, with hashmap)\n# ---------------------------\nleft = 0\nmax_len = 0\ncount = {}\n\nfor right in range(len(s)):\n    char = s[right]\n    count[char] = count.get(char, 0) + 1\n\n    # Shrink window while it violates a condition\n    while window_invalid:\n        count[s[left]] -= 1\n        if count[s[left]] == 0:\n            del count[s[left]]\n        left += 1\n\n    max_len = max(max_len, right - left + 1)\n\n\n# ---------------------------\n# Version 3: Dynamic Window (optimized counters, no hashmap)\n# ---------------------------\nleft = 0\nmax_len = 0\ncounter = 0  # counts \"bad\" elements in the window (e.g., zeros)\n\nfor right in range(len(nums)):\n    if nums[right] == bad_element:  # e.g., 0 in binary arrays\n        counter += 1\n\n    # Shrink window if it violates the allowed limit\n    while counter > limit:\n        if nums[left] == bad_element:\n            counter -= 1\n        left += 1\n\n    max_len = max(max_len, right - left + 1)  # adjust -1 if problem requires deletion",
      "javascript": "// ---------------------------\n// Version 1: Fixed-Size Window (size = k)\n// ---------------------------\nlet left = 0;\nlet windowSum = 0;\nlet best = 0;\n\nfor (let right = 0; right < arr.length; right++) {\n    windowSum += arr[right];\n\n    if (right - left + 1 === k) {\n        best = Math.max(best, windowSum);\n        windowSum -= arr[left];\n        left++;\n    }\n}\n\n// ---------------------------\n// Version 2: Dynamic Window (variable size, with hashmap)\n// ---------------------------\nlet left2 = 0;\nlet maxLen = 0;\nlet count = {};\n\nfor (let right = 0; right < s.length; right++) {\n    const char = s[right];\n    count[char] = (count[char] || 0) + 1;\n\n    while (windowInvalid) {\n        count[s[left2]]--;\n        if (count[s[left2]] === 0) delete count[s[left2]];\n        left2++;\n    }\n\n    maxLen = Math.max(maxLen, right - left2 + 1);\n}\n\n// ---------------------------\n// Version 3: Dynamic Window (optimized counters, no hashmap)\n// ---------------------------\nlet left3 = 0;\nlet maxLen2 = 0;\nlet counter = 0; // counts bad elements\n\nfor (let right = 0; right < nums.length; right++) {\n    if (nums[right] === badElement) counter++;\n\n    while (counter > limit) {\n        if (nums[left3] === badElement) counter--;\n        left3++;\n    }\n\n    maxLen2 = Math.max(maxLen2, right - left3 + 1);\n}",
      "java": "// ---------------------------\n// Version 1: Fixed-Size Window (size = k)\n// ---------------------------\nint left = 0;\nint windowSum = 0;\nint best = 0;\n\nfor (int right = 0; right < arr.length; right++) {\n    windowSum += arr[right];\n\n    if (right - left + 1 == k) {\n        best = Math.max(best, windowSum);\n        windowSum -= arr[left];\n        left++;\n    }\n}\n\n// ---------------------------\n// Version 2: Dynamic Window (variable size, with hashmap)\n// ---------------------------\nint left2 = 0;\nint maxLen = 0;\nMap<Character, Integer> count = new HashMap<>();\n\nfor (int right = 0; right < s.length(); right++) {\n    char c = s.charAt(right);\n    count.put(c, count.getOrDefault(c, 0) + 1);\n\n    while (windowInvalid) {\n        char lc = s.charAt(left2);\n        count.put(lc, count.get(lc) - 1);\n        if (count.get(lc) == 0) count.remove(lc);\n        left2++;\n    }\n\n    maxLen = Math.max(maxLen, right - left2 + 1);\n}\n\n// ---------------------------\n// Version 3: Dynamic Window (optimized counters, no hashmap)\n// ---------------------------\nint left3 = 0;\nint maxLen2 = 0;\nint counter = 0;\n\nfor (int right = 0; right < nums.length; right++) {\n    if (nums[right] == badElement) counter++;\n\n    while (counter > limit) {\n        if (nums[left3] == badElement) counter--;\n        left3++;\n    }\n\n    maxLen2 = Math.max(maxLen2, right - left3 + 1);\n}",
      "go": "// ---------------------------\n// Version 1: Fixed-Size Window (size = k)\n// ---------------------------\nleft := 0\nwindowSum := 0\nbest := 0\n\nfor right := 0; right < len(arr); right++ {\n    windowSum += arr[right]\n\n    if right-left+1 == k {\n        if windowSum > best {\n            best = windowSum\n        }\n        windowSum -= arr[left]\n        left++\n    }\n}\n\n// ---------------------------\n// Version 2: Dynamic Window (variable size, with hashmap)\n// ---------------------------\nleft2 := 0\nmaxLen := 0\ncount := make(map[rune]int)\n\nfor right, char := range s {\n    count[char]++\n\n    for windowInvalid {\n        leftChar := rune(s[left2])\n        count[leftChar]--\n        if count[leftChar] == 0 {\n            delete(count, leftChar)\n        }\n        left2++\n    }\n\n    if right-left2+1 > maxLen {\n        maxLen = right-left2+1\n    }\n}\n\n// ---------------------------\n// Version 3: Dynamic Window (optimized counters, no hashmap)\n// ---------------------------\nleft3 := 0\nmaxLen2 := 0\ncounter := 0\n\nfor right := 0; right < len(nums); right++ {\n    if nums[right] == badElement {\n        counter++\n    }\n\n    for counter > limit {\n        if nums[left3] == badElement {\n            counter--\n        }\n        left3++\n    }\n\n    if right-left3+1 > maxLen2 {\n        maxLen2 = right-left3+1\n    }\n}"
    },
    "problems": [
      "Maximum Sum Subarray of Size K",
      "Count Good Substrings of Size K",
      "Longest Substring Without Repeating Characters",
      "Longest Substring with K Distinct Characters",
      "Minimum Window Substring",
      "Permutation in String",
      "Smallest Subarray With Sum ≥ Target",
      "Longest Subarray of 1's After Deleting One Element",
      "Max Consecutive Ones III"
    ]
  },
  {
    "title": "Monotonic Stack",
    "description": "Used for finding next/previous greater or smaller elements. Maintains elements in monotonic (increasing or decreasing) order. Two variants: (1) Monotonic Decreasing Stack - for next greater element problems; (2) Monotonic Increasing Stack - for next smaller element problems. The stack stores indices (not values) to track positions.",
    "templates": {
      "python": "# ---------------------------\n# Version 1: Monotonic Decreasing (Next Greater Element)\n# ---------------------------\nstack = []  # stores indices\nresult = [-1] * len(arr)\n\nfor i in range(len(arr)):\n    # Pop smaller elements - current is their next greater\n    while stack and arr[stack[-1]] < arr[i]:\n        idx = stack.pop()\n        result[idx] = arr[i]\n    stack.append(i)\n\n\n# ---------------------------\n# Version 2: Monotonic Increasing (Next Smaller Element)\n# ---------------------------\nstack = []  # stores indices\nresult = [-1] * len(arr)\n\nfor i in range(len(arr)):\n    # Pop larger elements - current is their next smaller\n    while stack and arr[stack[-1]] > arr[i]:\n        idx = stack.pop()\n        result[idx] = arr[i]\n    stack.append(i)\n\n\n# ---------------------------\n# Version 3: Previous Greater/Smaller (traverse left to right)\n# ---------------------------\nstack = []\nresult = [-1] * len(arr)\n\nfor i in range(len(arr)):\n    # Pop until we find previous greater (or smaller)\n    while stack and arr[stack[-1]] <= arr[i]:  # change condition as needed\n        stack.pop()\n    \n    if stack:\n        result[i] = arr[stack[-1]]  # previous greater element\n    \n    stack.append(i)",
      "javascript": "// ---------------------------\n// Version 1: Monotonic Decreasing (Next Greater Element)\n// ---------------------------\nconst stack = [];  // stores indices\nconst result = new Array(arr.length).fill(-1);\n\nfor (let i = 0; i < arr.length; i++) {\n    // Pop smaller elements - current is their next greater\n    while (stack.length && arr[stack[stack.length - 1]] < arr[i]) {\n        const idx = stack.pop();\n        result[idx] = arr[i];\n    }\n    stack.push(i);\n}\n\n\n// ---------------------------\n// Version 2: Monotonic Increasing (Next Smaller Element)\n// ---------------------------\nconst stack2 = [];  // stores indices\nconst result2 = new Array(arr.length).fill(-1);\n\nfor (let i = 0; i < arr.length; i++) {\n    // Pop larger elements - current is their next smaller\n    while (stack2.length && arr[stack2[stack2.length - 1]] > arr[i]) {\n        const idx = stack2.pop();\n        result2[idx] = arr[i];\n    }\n    stack2.push(i);\n}\n\n\n// ---------------------------\n// Version 3: Previous Greater/Smaller (traverse left to right)\n// ---------------------------\nconst stack3 = [];\nconst result3 = new Array(arr.length).fill(-1);\n\nfor (let i = 0; i < arr.length; i++) {\n    // Pop until we find previous greater (or smaller)\n    while (stack3.length && arr[stack3[stack3.length - 1]] <= arr[i]) {\n        stack3.pop();\n    }\n    \n    if (stack3.length) {\n        result3[i] = arr[stack3[stack3.length - 1]];\n    }\n    \n    stack3.push(i);\n}",
      "java": "// ---------------------------\n// Version 1: Monotonic Decreasing (Next Greater Element)\n// ---------------------------\nStack<Integer> stack = new Stack<>();  // stores indices\nint[] result = new int[arr.length];\nArrays.fill(result, -1);\n\nfor (int i = 0; i < arr.length; i++) {\n    // Pop smaller elements - current is their next greater\n    while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {\n        int idx = stack.pop();\n        result[idx] = arr[i];\n    }\n    stack.push(i);\n}\n\n\n// ---------------------------\n// Version 2: Monotonic Increasing (Next Smaller Element)\n// ---------------------------\nStack<Integer> stack2 = new Stack<>();  // stores indices\nint[] result2 = new int[arr.length];\nArrays.fill(result2, -1);\n\nfor (int i = 0; i < arr.length; i++) {\n    // Pop larger elements - current is their next smaller\n    while (!stack2.isEmpty() && arr[stack2.peek()] > arr[i]) {\n        int idx = stack2.pop();\n        result2[idx] = arr[i];\n    }\n    stack2.push(i);\n}\n\n\n// ---------------------------\n// Version 3: Previous Greater/Smaller (traverse left to right)\n// ---------------------------\nStack<Integer> stack3 = new Stack<>();\nint[] result3 = new int[arr.length];\nArrays.fill(result3, -1);\n\nfor (int i = 0; i < arr.length; i++) {\n    // Pop until we find previous greater (or smaller)\n    while (!stack3.isEmpty() && arr[stack3.peek()] <= arr[i]) {\n        stack3.pop();\n    }\n    \n    if (!stack3.isEmpty()) {\n        result3[i] = arr[stack3.peek()];\n    }\n    \n    stack3.push(i);\n}",
      "go": "// ---------------------------\n// Version 1: Monotonic Decreasing (Next Greater Element)\n// ---------------------------\nstack := []int{}  // stores indices\nresult := make([]int, len(arr))\nfor i := range result {\n    result[i] = -1\n}\n\nfor i := 0; i < len(arr); i++ {\n    // Pop smaller elements - current is their next greater\n    for len(stack) > 0 && arr[stack[len(stack)-1]] < arr[i] {\n        idx := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        result[idx] = arr[i]\n    }\n    stack = append(stack, i)\n}\n\n\n// ---------------------------\n// Version 2: Monotonic Increasing (Next Smaller Element)\n// ---------------------------\nstack2 := []int{}  // stores indices\nresult2 := make([]int, len(arr))\nfor i := range result2 {\n    result2[i] = -1\n}\n\nfor i := 0; i < len(arr); i++ {\n    // Pop larger elements - current is their next smaller\n    for len(stack2) > 0 && arr[stack2[len(stack2)-1]] > arr[i] {\n        idx := stack2[len(stack2)-1]\n        stack2 = stack2[:len(stack2)-1]\n        result2[idx] = arr[i]\n    }\n    stack2 = append(stack2, i)\n}\n\n\n// ---------------------------\n// Version 3: Previous Greater/Smaller (traverse left to right)\n// ---------------------------\nstack3 := []int{}\nresult3 := make([]int, len(arr))\nfor i := range result3 {\n    result3[i] = -1\n}\n\nfor i := 0; i < len(arr); i++ {\n    // Pop until we find previous greater (or smaller)\n    for len(stack3) > 0 && arr[stack3[len(stack3)-1]] <= arr[i] {\n        stack3 = stack3[:len(stack3)-1]\n    }\n    \n    if len(stack3) > 0 {\n        result3[i] = arr[stack3[len(stack3)-1]]\n    }\n    \n    stack3 = append(stack3, i)\n}"
    },
    "problems": [
      "Next Greater Element I",
      "Next Greater Element II",
      "Daily Temperatures",
      "Largest Rectangle in Histogram",
      "Trapping Rain Water",
      "Remove K Digits",
      "Online Stock Span"
    ]
  },
  {
    "title": "Fast and Slow Pointers",
    "description": "Used for cycle detection in linked lists or arrays.",
    "templates": {
      "python": "def hasCycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
      "javascript": "function hasCycle(head) {\n    let slow = head, fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n}",
      "java": "public boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}",
      "go": "func hasCycle(head *ListNode) bool {\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}"
    },
    "problems": [
      "Linked List Cycle",
      "Find Duplicate Number",
      "Middle of the Linked List"
    ]
  },
  {
    "title": "Hashing (Set / Dictionary)",
    "description": "Used for frequency counting, quick lookup.",
    "templates": {
      "python": "freq = {}\nfor num in arr:\n    freq[num] = freq.get(num, 0) + 1",
      "javascript": "const freq = {};\nfor (const num of arr) {\n    freq[num] = (freq[num] || 0) + 1;\n}",
      "java": "Map<Integer, Integer> freq = new HashMap<>();\nfor (int num : arr) {\n    freq.put(num, freq.getOrDefault(num, 0) + 1);\n}",
      "go": "freq := make(map[int]int)\nfor _, num := range arr {\n    freq[num]++\n}"
    },
    "problems": ["Two Sum", "Group Anagrams", "Top K Frequent Elements"]
  },
  {
    "title": "Binary Search",
    "description": "Used for sorted arrays and search space problems. Three main variants: (1) Standard Binary Search - finds exact target; (2) Lower Bound - finds first position where arr[i] >= target (leftmost insertion point); (3) Upper Bound - finds first position where arr[i] > target (rightmost insertion point). Lower/Upper bounds are useful for finding insert positions, range queries, and 'at least/at most' problems.",
    "templates": {
      "python": "# ---------------------------\n# Version 1: Standard Binary Search (find exact target)\n# ---------------------------\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\n# ---------------------------\n# Version 2: Lower Bound (first position >= target)\n# ---------------------------\ndef lower_bound(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left  # returns len(arr) if all elements < target\n\n\n# ---------------------------\n# Version 3: Upper Bound (first position > target)\n# ---------------------------\ndef upper_bound(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left  # returns len(arr) if all elements <= target",
      "javascript": "// ---------------------------\n// Version 1: Standard Binary Search (find exact target)\n// ---------------------------\nfunction binarySearch(arr, target) {\n    let left = 0, right = arr.length - 1;\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid] === target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n\n// ---------------------------\n// Version 2: Lower Bound (first position >= target)\n// ---------------------------\nfunction lowerBound(arr, target) {\n    let left = 0, right = arr.length;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;  // returns arr.length if all elements < target\n}\n\n\n// ---------------------------\n// Version 3: Upper Bound (first position > target)\n// ---------------------------\nfunction upperBound(arr, target) {\n    let left = 0, right = arr.length;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (arr[mid] <= target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;  // returns arr.length if all elements <= target\n}",
      "java": "// ---------------------------\n// Version 1: Standard Binary Search (find exact target)\n// ---------------------------\npublic int binarySearch(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n\n// ---------------------------\n// Version 2: Lower Bound (first position >= target)\n// ---------------------------\npublic int lowerBound(int[] arr, int target) {\n    int left = 0, right = arr.length;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;  // returns arr.length if all elements < target\n}\n\n\n// ---------------------------\n// Version 3: Upper Bound (first position > target)\n// ---------------------------\npublic int upperBound(int[] arr, int target) {\n    int left = 0, right = arr.length;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] <= target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;  // returns arr.length if all elements <= target\n}",
      "go": "// ---------------------------\n// Version 1: Standard Binary Search (find exact target)\n// ---------------------------\nfunc binarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n    for left <= right {\n        mid := left + (right-left)/2\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\n\n// ---------------------------\n// Version 2: Lower Bound (first position >= target)\n// ---------------------------\nfunc lowerBound(arr []int, target int) int {\n    left, right := 0, len(arr)\n    for left < right {\n        mid := left + (right-left)/2\n        if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    return left  // returns len(arr) if all elements < target\n}\n\n\n// ---------------------------\n// Version 3: Upper Bound (first position > target)\n// ---------------------------\nfunc upperBound(arr []int, target int) int {\n    left, right := 0, len(arr)\n    for left < right {\n        mid := left + (right-left)/2\n        if arr[mid] <= target {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    return left  // returns len(arr) if all elements <= target\n}"
    },
    "problems": [
      "Binary Search",
      "Search Insert Position",
      "Find Minimum in Rotated Sorted Array",
      "Find First and Last Position of Element in Sorted Array",
      "Search in Rotated Sorted Array",
      "Koko Eating Bananas",
      "Capacity To Ship Packages Within D Days"
    ]
  },
  {
    "title": "Prefix Sum",
    "description": "Used for fast range sum queries and subarray sum problems. Two common implementations: (1) with an extra 0 at the start, which makes range sums easier, and (2) without the extra 0, using 0-based indexing.",
    "templates": {
      "python": "# ---------------------------\n# Version 1: With extra 0 at the start (simpler range queries)\n# ---------------------------\nprefix = [0] * (len(arr) + 1)\nfor i in range(len(arr)):\n    prefix[i + 1] = prefix[i] + arr[i]\n\n# ---------------------------\n# Version 2: Without extra 0 (0-based indexing)\n# ---------------------------\nprefix = [0] * len(arr)\nprefix[0] = arr[0]\nfor i in range(1, len(arr)):\n    prefix[i] = prefix[i - 1] + arr[i]",
      "javascript": "// ---------------------------\n// Version 1: With extra 0 at the start (simpler range queries)\n// ---------------------------\nconst prefix = new Array(arr.length + 1).fill(0);\nfor (let i = 0; i < arr.length; i++) {\n    prefix[i + 1] = prefix[i] + arr[i];\n}\n\n// ---------------------------\n// Version 2: Without extra 0 (0-based indexing)\n// ---------------------------\nconst prefix2 = new Array(arr.length).fill(0);\nprefix2[0] = arr[0];\nfor (let i = 1; i < arr.length; i++) {\n    prefix2[i] = prefix2[i - 1] + arr[i];",
      "java": "// ---------------------------\n// Version 1: With extra 0 at the start (simpler range queries)\n// ---------------------------\nint[] prefix = new int[arr.length + 1];\nfor (int i = 0; i < arr.length; i++) {\n    prefix[i + 1] = prefix[i] + arr[i];\n}\n\n// ---------------------------\n// Version 2: Without extra 0 (0-based indexing)\n// ---------------------------\nint[] prefix2 = new int[arr.length];\nprefix2[0] = arr[0];\nfor (int i = 1; i < arr.length; i++) {\n    prefix2[i] = prefix2[i - 1] + arr[i];",
      "go": "// ---------------------------\n// Version 1: With extra 0 at the start (simpler range queries)\n// ---------------------------\nprefix := make([]int, len(arr)+1)\nfor i := 0; i < len(arr); i++ {\n    prefix[i+1] = prefix[i] + arr[i]\n}\n\n// ---------------------------\n// Version 2: Without extra 0 (0-based indexing)\n// ---------------------------\nprefix2 := make([]int, len(arr))\nprefix2[0] = arr[0]\nfor i := 1; i < len(arr); i++ {\n    prefix2[i] = prefix2[i-1] + arr[i];"
    },
    "problems": [
      "Subarray Sum Equals K",
      "Range Sum Query",
      "Continuous Subarray Sum"
    ]
  },
  {
    "title": "Backtracking",
    "description": "Used for generating combinations/permutations.",
    "templates": {
      "python": "def backtrack(path, options):\n    if base_case:\n        result.append(path[:])\n        return\n    for i in range(len(options)):\n        path.append(options[i])\n        backtrack(path, options[i+1:])\n        path.pop()",
      "javascript": "function backtrack(path, options) {\n    if (baseCase) {\n        result.push([...path]);\n        return;\n    }\n    for (let i = 0; i < options.length; i++) {\n        path.push(options[i]);\n        backtrack(path, options.slice(i + 1));\n        path.pop();\n    }\n}",
      "java": "public void backtrack(List<Integer> path, int[] options, int start) {\n    if (baseCase) {\n        result.add(new ArrayList<>(path));\n        return;\n    }\n    for (int i = start; i < options.length; i++) {\n        path.add(options[i]);\n        backtrack(path, options, i + 1);\n        path.remove(path.size() - 1);\n    }\n}",
      "go": "func backtrack(path []int, options []int, start int) {\n    if baseCase {\n        result = append(result, append([]int{}, path...))\n        return\n    }\n    for i := start; i < len(options); i++ {\n        path = append(path, options[i])\n        backtrack(path, options, i+1)\n        path = path[:len(path)-1]\n    }\n}"
    },
    "problems": ["Subsets", "Permutations", "N-Queens"]
  },
  {
    "title": "DFS for Trees",
    "description": "Used for traversals, height calculation, path sums.",
    "templates": {
      "python": "def dfs_tree(node):\n    if not node:\n        return\n    # Preorder processing\n    dfs_tree(node.left)\n    dfs_tree(node.right)\n    # Postorder processing",
      "javascript": "function dfsTree(node) {\n    if (!node) return;\n    // Preorder processing\n    dfsTree(node.left);\n    dfsTree(node.right);\n    // Postorder processing\n}",
      "java": "public void dfsTree(TreeNode node) {\n    if (node == null) return;\n    // Preorder processing\n    dfsTree(node.left);\n    dfsTree(node.right);\n    // Postorder processing\n}",
      "go": "func dfsTree(node *TreeNode) {\n    if node == nil {\n        return\n    }\n    // Preorder processing\n    dfsTree(node.Left)\n    dfsTree(node.Right)\n    // Postorder processing\n}"
    },
    "problems": ["Max Depth of Binary Tree", "Path Sum", "Balanced Binary Tree"]
  },
  {
    "title": "BFS for Trees",
    "description": "Used for level order traversal, shortest path in trees.",
    "templates": {
      "python": "from collections import deque\n\ndef bfs_tree(root):\n    if not root:\n        return\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        # process node\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)",
      "javascript": "function bfsTree(root) {\n    if (!root) return;\n    const queue = [root];\n    while (queue.length > 0) {\n        const node = queue.shift();\n        // process node\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n    }\n}",
      "java": "public void bfsTree(TreeNode root) {\n    if (root == null) return;\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        // process node\n        if (node.left != null) queue.offer(node.left);\n        if (node.right != null) queue.offer(node.right);\n    }\n}",
      "go": "func bfsTree(root *TreeNode) {\n    if root == nil {\n        return\n    }\n    queue := []*TreeNode{root}\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        // process node\n        if node.Left != nil {\n            queue = append(queue, node.Left)\n        }\n        if node.Right != nil {\n            queue = append(queue, node.Right)\n        }\n    }\n}"
    },
    "problems": [
      "Binary Tree Level Order Traversal",
      "Minimum Depth of Binary Tree"
    ]
  },
  {
    "title": "Dynamic Programming (DP)",
    "description": "Used for optimal substructure, overlapping subproblems.",
    "templates": {
      "python": "# Memoization approach\ndef dp(i, memo={}):\n    if i in memo:\n        return memo[i]\n    if base_case:\n        return result\n    memo[i] = compute_from_smaller(i)\n    return memo[i]\n\n# Tabulation approach\ndp = [0] * (n + 1)\ndp[0] = base_case\nfor i in range(1, n + 1):\n    dp[i] = compute_from_smaller(i)",
      "javascript": "// Memoization approach\nfunction dp(i, memo = {}) {\n    if (i in memo) return memo[i];\n    if (baseCase) return result;\n    memo[i] = computeFromSmaller(i);\n    return memo[i];\n}\n\n// Tabulation approach\nconst dp = new Array(n + 1).fill(0);\ndp[0] = baseCase;\nfor (let i = 1; i <= n; i++) {\n    dp[i] = computeFromSmaller(i);\n}",
      "java": "// Memoization approach\nMap<Integer, Integer> memo = new HashMap<>();\npublic int dp(int i) {\n    if (memo.containsKey(i)) return memo.get(i);\n    if (baseCase) return result;\n    int res = computeFromSmaller(i);\n    memo.put(i, res);\n    return res;\n}\n\n// Tabulation approach\nint[] dp = new int[n + 1];\ndp[0] = baseCase;\nfor (int i = 1; i <= n; i++) {\n    dp[i] = computeFromSmaller(i);\n}",
      "go": "// Memoization approach\nmemo := make(map[int]int)\nfunc dp(i int) int {\n    if val, ok := memo[i]; ok {\n        return val\n    }\n    if baseCase {\n        return result\n    }\n    memo[i] = computeFromSmaller(i)\n    return memo[i]\n}\n\n// Tabulation approach\ndp := make([]int, n+1)\ndp[0] = baseCase\nfor i := 1; i <= n; i++ {\n    dp[i] = computeFromSmaller(i)\n}"
    },
    "problems": [
      "Climbing Stairs",
      "House Robber",
      "Longest Increasing Subsequence"
    ]
  },
  {
    "title": "Topological Sort",
    "description": "Kahn’s Algorithm for ordering nodes in a Directed Acyclic Graph (DAG) based on dependencies. Used for task scheduling.",
    "templates": {
      "python": "from collections import deque\nindegree = {u: 0 for u in range(n)}\nfor u, v in edges: indegree[v] += 1\nqueue = deque([u for u in indegree if indegree[u] == 0])\norder = []\nwhile queue:\n    u = queue.popleft()\n    order.append(u)\n    for v in adj[u]:\n        indegree[v] -= 1\n        if indegree[v] == 0: queue.append(v)\nreturn order if len(order) == n else []",
      "javascript": "const indegree = new Array(n).fill(0);\nfor (const [u, v] of edges) indegree[v]++;\nconst queue = [], order = [];\nfor (let i = 0; i < n; i++) if (indegree[i] === 0) queue.push(i);\nwhile (queue.length) {\n    const u = queue.shift();\n    order.push(u);\n    for (const v of adj[u]) {\n        if (--indegree[v] === 0) queue.push(v);\n    }\n}\nreturn order.length === n ? order : [];",
      "java": "int[] indegree = new int[n];\nfor (int[] e : edges) indegree[e[1]]++;\nQueue<Integer> q = new LinkedList<>();\nfor (int i = 0; i < n; i++) if (indegree[i] == 0) q.offer(i);\nList<Integer> order = new ArrayList<>();\nwhile (!q.isEmpty()) {\n    int u = q.poll(); order.add(u);\n    for (int v : adj.get(u)) {\n        if (--indegree[v] == 0) q.offer(v);\n    }\n}\nreturn order.size() == n ? order : new ArrayList<>();",
      "go": "indegree := make([]int, n)\nfor _, e := range edges { indegree[e[1]]++ }\nqueue := []int{}\nfor i, deg := range indegree { if deg == 0 { queue = append(queue, i) } }\norder := []int{}\nfor len(queue) > 0 {\n    u := queue[0]; queue = queue[1:]; order = append(order, u)\n    for _, v := range adj[u] {\n        indegree[v]--\n        if indegree[v] == 0 { queue = append(queue, v) }\n    }\n}\nif len(order) != n { return []int{} }; return order"
    },
    "problems": [
      "Course Schedule I & II",
      "Alien Dictionary",
      "Sequence Reconstruction"
    ]
  },
  {
    "title": "Union Find (Disjoint Set)",
    "description": "Efficiently manages connected components. Features path compression and union by rank/size for nearly O(1) operations.",
    "templates": {
      "python": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n    def find(self, i):\n        if self.parent[i] == i: return i\n        self.parent[i] = self.find(self.parent[i]) # path compression\n        return self.parent[i]\n    def union(self, i, j):\n        root_i, root_j = self.find(i), self.find(j)\n        if root_i != root_j: self.parent[root_i] = root_j",
      "javascript": "class UnionFind {\n    constructor(n) { this.parent = Array.from({length: n}, (_, i) => i); }\n    find(i) {\n        if (this.parent[i] === i) return i;\n        return this.parent[i] = this.find(this.parent[i]);\n    }\n    union(i, j) {\n        let rootI = this.find(i), rootJ = this.find(j);\n        if (rootI !== rootJ) this.parent[rootI] = rootJ;\n    }\n}",
      "java": "class UnionFind {\n    int[] parent;\n    public UnionFind(int n) {\n        parent = new int[n];\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    public int find(int i) {\n        if (parent[i] == i) return i;\n        return parent[i] = find(parent[i]);\n    }\n    public void union(int i, int j) {\n        int rootI = find(i), rootJ = find(j);\n        if (rootI != rootJ) parent[rootI] = rootJ;\n    }\n}",
      "go": "type UnionFind struct { parent []int }\nfunc NewUF(n int) *UnionFind {\n    p := make([]int, n); for i := range p { p[i] = i }\n    return &UnionFind{p}\n}\nfunc (uf *UnionFind) Find(i int) int {\n    if uf.parent[i] == i { return i }\n    uf.parent[i] = uf.Find(uf.parent[i]); return uf.parent[i]\n}\nfunc (uf *UnionFind) Union(i, j int) {\n    rootI, rootJ := uf.Find(i), uf.Find(j)\n    if rootI != rootJ { uf.parent[rootI] = rootJ }\n}"
    },
    "problems": [
      "Number of Connected Components",
      "Graph Valid Tree",
      "Redundant Connection",
      "Kruskal's MST"
    ]
  },
  {
    "title": "Trie (Prefix Tree)",
    "description": "Used for efficient string prefix matching and search. Each node contains a map/array of children and an 'isEndOfWord' flag.",
    "templates": {
      "python": "class TrieNode:\n    def __init__(self): \n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def insert(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children: curr.children[char] = TrieNode()\n            curr = curr.children[char]\n        curr.is_word = True",
      "javascript": "class TrieNode {\n    constructor() { this.children = {}; this.isWord = false; }\n}\nclass Trie {\n    insert(word) {\n        let curr = this.root;\n        for (let char of word) {\n            if (!curr.children[char]) curr.children[char] = new TrieNode();\n            curr = curr.children[char];\n        }\n        curr.isWord = true;\n    }\n}",
      "java": "class TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isWord = false;\n}\nclass Trie {\n    public void insert(String word) {\n        TrieNode curr = root;\n        for (char c : word.toCharArray()) {\n            if (curr.children[c-'a'] == null) curr.children[c-'a'] = new TrieNode();\n            curr = curr.children[c-'a'];\n        }\n        curr.isWord = true;\n    }\n}",
      "go": "type TrieNode struct {\n    children map[rune]*TrieNode\n    isWord   bool\n}\nfunc (t *TrieNode) Insert(word string) {\n    curr := t\n    for _, char := range word {\n        if curr.children[char] == nil { curr.children[char] = &TrieNode{children: make(map[rune]*TrieNode)} }\n        curr = curr.children[char]\n    }\n    curr.isWord = true\n}"
    },
    "problems": [
      "Implement Trie",
      "Word Search II",
      "Replace Words",
      "Design Add and Search Words Data Structure"
    ]
  },
  {
    "title": "Heap / Priority Queue",
    "description": "Maintains a running 'top K' elements. Min-heap for K largest elements, Max-heap for K smallest elements. Python and Java have built-in support; JS requires a manual implementation or sorted array for simple cases.",
    "templates": {
      "python": "import heapq\n# Min-Heap (K largest elements)\nheap = []\nfor num in nums:\n    heapq.heappush(heap, num)\n    if len(heap) > k: heapq.heappop(heap)\nreturn heap[0] # The Kth largest",
      "javascript": "// JS lacks built-in Heap. For Kth largest, maintain sorted array length K\nlet minHeap = [];\nfor (let num of nums) {\n    minHeap.push(num);\n    minHeap.sort((a, b) => a - b);\n    if (minHeap.length > k) minHeap.shift();\n}\nreturn minHeap[0];",
      "java": "PriorityQueue<Integer> minHeap = new PriorityQueue<>();\nfor (int num : nums) {\n    minHeap.offer(num);\n    if (minHeap.size() > k) minHeap.poll();\n}\nreturn minHeap.peek();",
      "go": "// Go requires implementing container/heap. Interface\ntype IntHeap []int\nfunc (h IntHeap) Len() int           { return len(h) }\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *IntHeap) Push(x any)        { *h = append(*h, x.(int)) }\nfunc (h *IntHeap) Pop() any          { old := *h; n := len(old); x := old[n-1]; *h = old[0 : n-1]; return x }"
    },
    "problems": [
      "Kth Largest Element in an Array",
      "Top K Frequent Elements",
      "Merge K Sorted Lists",
      "Find Median from Data Stream"
    ]
  },
  {
    "title": "DFS for Graphs",
    "description": "Used for connectivity, path finding, and cycle detection. Unlike trees, graphs can have cycles, so a 'visited' set is required to avoid infinite loops.",
    "templates": {
      "python": "visited = set()\ndef dfs(node):\n    if node in visited:\n        return\n    visited.add(node)\n    # Process node\n    for neighbor in adj[node]:\n        dfs(neighbor)",
      "javascript": "const visited = new Set();\nfunction dfs(node) {\n    if (visited.has(node)) return;\n    visited.add(node);\n    // Process node\n    for (let neighbor of adj[node]) {\n        dfs(neighbor);\n    }\n}",
      "java": "Set<Integer> visited = new HashSet<>();\npublic void dfs(int node, Map<Integer, List<Integer>> adj) {\n    if (visited.contains(node)) return;\n    visited.add(node);\n    // Process node\n    for (int neighbor : adj.getOrDefault(node, new ArrayList<>())) {\n        dfs(neighbor, adj);\n    }\n}",
      "go": "visited := make(map[int]bool)\nfunc dfs(node int, adj map[int][]int) {\n    if visited[node] {\n        return\n    }\n    visited[node] = true\n    // Process node\n    for _, neighbor := range adj[node] {\n        dfs(neighbor, adj)\n    }\n}"
    },
    "problems": [
      "Number of Islands",
      "Clone Graph",
      "Course Schedule (Cycle Detection)",
      "All Paths From Source to Target"
    ]
  },
  {
    "title": "BFS for Graphs",
    "description": "Used for finding the shortest path in unweighted graphs and level-order traversal. Uses a queue and a 'visited' set.",
    "templates": {
      "python": "from collections import deque\n\ndef bfs(start_node):\n    queue = deque([start_node])\n    visited = {start_node}\n    \n    while queue:\n        node = queue.popleft()\n        # Process node\n        for neighbor in adj[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)",
      "javascript": "function bfs(startNode) {\n    const queue = [startNode];\n    const visited = new Set([startNode]);\n\n    while (queue.length > 0) {\n        const node = queue.shift();\n        // Process node\n        for (let neighbor of adj[node]) {\n            if (!visited.has(neighbor)) {\n                visited.add(neighbor);\n                queue.push(neighbor);\n            }\n        }\n    }\n}",
      "java": "public void bfs(int startNode, Map<Integer, List<Integer>> adj) {\n    Queue<Integer> queue = new LinkedList<>();\n    Set<Integer> visited = new HashSet<>();\n\n    queue.offer(startNode);\n    visited.add(startNode);\n\n    while (!queue.isEmpty()) {\n        int node = queue.poll();\n        // Process node\n        for (int neighbor : adj.getOrDefault(node, new ArrayList<>())) {\n            if (!visited.contains(neighbor)) {\n                visited.add(neighbor);\n                queue.offer(neighbor);\n            }\n        }\n    }\n}",
      "go": "func bfs(startNode int, adj map[int][]int) {\n    queue := []int{startNode}\n    visited := map[int]bool{startNode: true}\n\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        // Process node\n        for _, neighbor := range adj[node] {\n            if !visited[neighbor] {\n                visited[neighbor] = true\n                queue = append(queue, neighbor)\n            }\n        }\n    }\n}"
    },
    "problems": [
      "Shortest Path in Binary Matrix",
      "Rotting Oranges",
      "Word Ladder"
    ]
  },
  {
    "title": "Dijkstra's Algorithm",
    "description": "Finds the shortest path from a source to all other nodes in a weighted graph with non-negative edge weights. Uses a Priority Queue (Min-Heap).",
    "templates": {
      "python": "import heapq\n\ndef dijkstra(start, nodes_count, adj):\n    distances = {i: float('inf') for i in range(nodes_count)}\n    distances[start] = 0\n    pq = [(0, start)]  # (distance, node)\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > distances[u]: continue\n\n        for v, weight in adj[u]:\n            if distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                heapq.heappush(pq, (distances[v], v))\n    return distances",
      "javascript": "// Note: JS doesn't have a built-in Priority Queue. \n// In interviews, you may need to implement a simple one or use a sorted array.\nfunction dijkstra(start, adj) {\n    const distances = {};\n    for (let node in adj) distances[node] = Infinity;\n    distances[start] = 0;\n    const pq = [[0, start]]; // [distance, node]\n\n    while (pq.length > 0) {\n        pq.sort((a, b) => a[0] - b[0]);\n        const [d, u] = pq.shift();\n\n        if (d > distances[u]) continue;\n\n        for (let [v, weight] of adj[u]) {\n            if (distances[u] + weight < distances[v]) {\n                distances[v] = distances[u] + weight;\n                pq.push([distances[v], v]);\n            }\n        }\n    }\n    return distances;\n}",
      "java": "public int[] dijkstra(int n, List<int[]>[] adj, int start) {\n    int[] dist = new int[n];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[start] = 0;\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n    pq.offer(new int[]{0, start});\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int d = curr[0], u = curr[1];\n        if (d > dist[u]) continue;\n\n        for (int[] edge : adj[u]) {\n            int v = edge[0], weight = edge[1];\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.offer(new int[]{dist[v], v});\n            }\n        }\n    }\n    return dist;\n}",
      "go": "// Go requires implementing heap.Interface for a Priority Queue\nfunc dijkstra(start int, n int, adj map[int][][2]int) []int {\n    dist := make([]int, n)\n    for i := range dist { dist[i] = 1e9 }\n    dist[start] = 0\n    // Using a simple slice as a dummy PQ for logic demonstration\n    pq := [][2]int{{0, start}}\n\n    for len(pq) > 0 {\n        // In real Go code, use container/heap to pop the minimum\n        u := pq[0][1]; d := pq[0][0]; pq = pq[1:]\n        if d > dist[u] { continue }\n\n        for _, edge := range adj[u] {\n            v, weight := edge[0], edge[1]\n            if dist[u]+weight < dist[v] {\n                dist[v] = dist[u] + weight\n                pq = append(pq, [2]int{dist[v], v})\n            }\n        }\n    }\n    return dist\n}"
    },
    "problems": [
      "Network Delay Time",
      "Path with Maximum Probability",
      "Cheapest Flights Within K Stops"
    ]
  },
  {
    "title": "Bellman-Ford",
    "description": "Finds the shortest path from a source to all nodes in a graph that can have negative edge weights. Can also detect negative cycles.",
    "templates": {
      "python": "def bellman_ford(n, edges, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n\n    # Relax all edges n-1 times\n    for _ in range(n - 1):\n        for u, v, w in edges:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n\n    # Check for negative cycles\n    for u, v, w in edges:\n        if dist[u] != float('inf') and dist[u] + w < dist[v]:\n            print(\"Graph contains a negative weight cycle\")\n    \n    return dist",
      "javascript": "function bellmanFord(n, edges, start) {\n    let dist = new Array(n).fill(Infinity);\n    dist[start] = 0;\n\n    for (let i = 0; i < n - 1; i++) {\n        for (let [u, v, w] of edges) {\n            if (dist[u] !== Infinity && dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n    return dist;\n}",
      "java": "public int[] bellmanFord(int n, int[][] edges, int start) {\n    int[] dist = new int[n];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[start] = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            if (dist[u] != Integer.MAX_VALUE && dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n    return dist;\n}",
      "go": "func bellmanFord(n int, edges [][]int, start int) []int {\n    dist := make([]int, n)\n    for i := range dist { dist[i] = 1e9 }\n    dist[start] = 0\n\n    for i := 0; i < n-1; i++ {\n        for _, edge := range edges {\n            u, v, w := edge[0], edge[1], edge[2]\n            if dist[u] != 1e9 && dist[u]+w < dist[v] {\n                dist[v] = dist[u] + w\n            }\n        }\n    }\n    return dist\n}"
    },
    "problems": [
      "Cheapest Flights Within K Stops",
      "Find the City With the Smallest Number of Neighbors at a Threshold Distance"
    ]
  }
]
